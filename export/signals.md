# Сервисы, сигналы
## Cервисы
В операционной системе Linux, так же, как и в Windows, кроме обычных программ, которые могут взаимодействовать с пользователем, есть еще один вид программ. Это работающие в фоне службы, они следят за состоянием системы, обеспечивают автоматическое подключение внешних устройств и сети, позволяют процессам взаимодействовать с оборудованием (dbus), а также в виде служб реализованы различные веб-серверы и серверы баз данных. В отличие от пользовательских программ, службы выполняются в фоне, и пользователь не имеет к ним прямого доступа.

Существует такое понятие как **pid** - process id. Это - порядковый номер, назначаемый процессу при его старте. 
Самым первым стартует процесс **init**, его pid равен 1. Расположен по пути /sbin/init. Его назначение состоит в том, чтобы запустить все остальные процессы, рабочее окружение. 

*Кстати*, посмотреть список всех запущенных процессов можно набрав в консоли `ps aux`. Полученные значения pid можно использовать для взаимодействия с процессом, об этом поговорим ниже.

## Сигналы
Для работы с процессами был придуман и реализован механизм **сигналов.** Сигнал в операционных системах семейства Unix — асинхронное уведомление процесса о каком-либо событии, один из основных способов взаимодействия между процессами. Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный _обработчик сигнала_, операционная система запускает этот обработчик, передав ему информацию о сигнале, если процесс не установил обработчик, то выполняется обработчик по умолчанию.
POSIX определяет 28 сигналов, которые можно классифицировать следующим образом:

|Название|Код  | Действие по умолчанию| Описиние 
|--|--|--|--|
|Sighup     |1 | Завершение               |Закрытие терминала
|SIGINT     |2 |Завершение                |Сигнал прерывания (Ctrl+C) из терминала|
|SIGQUIT    |3 |Завершение с дампом памяти|Сигнал «Quit» с терминала (Ctrl-\) |
|SIGILL     |4 |Завершение с дампом памяти|Недопустимая инструкция процессора |
|SIGSTRAP   |5 |Завершение с дампом памяти|Ловушка трассировки или брейкпоинт |
|SIGABRT    |6 |Завершение с дампом памяти|Сигнал посылаемый функцией abort()|
|SIGFPE     |8 |Завершение с дампом памяти|Ошибочная арифметическая операция|
|**SIGKILL**|9 |**Завершение**            |**Безусловное завершение** |
|SIGBUS     |10|Завершение с дампом памяти|Неправильное обращение в физическую память |
|SIGSEGV    |11|Завершение с дампом памяти|Нарушение при обращении в память |
|SIGSYS     |12|Завершение с дампом памяти|Неправильный системный вызов |
|SIGPIPE    |13|Завершение                |Запись в разорванное соединение (пайп, сокет) |
|SIGALRM    |14|Завершение                |Сигнал истечения времени, заданного alarm() |
|SIGTERM    |15|Завершение                |Сигнал завершения (сигнал по умолчанию для утилиты kill) |
|SIGUSR1    |16|Завершение                |Пользовательский сигнал № 1 |
|SIGUSR2    |17|Завершение                |Пользовательский сигнал № 2 |
|SIGCHLD    |18|Игнорируется              |Дочерний процесс завершен или остановлен |
|SIGTSTP    |20|Остановка процесса        |Сигнал остановки с терминала (Ctrl-Z). |
|SIGURG     |21|Игнорируется              |На сокете получены срочные данные |
|SIGPOLL    |22|Завершение                |Событие, отслеживаемое poll() |
|**SIGSTOP**|23|**Остановка процесса**    |**Остановка выполнения процесса**|
|SIGCONT    |25|Продолжить выполнение     |Продолжить выполнение ранее остановленного процесса |
|SIGTTIN    |26|Остановка процесса        |Попытка чтения с терминала фоновым процессом |
|SIGTTOU    |27|Остановка процесса        |Попытка записи на терминал фоновым процессом |
|SIGVTALRM  |28|Завершение                |Истечение «виртуального таймера» |
|SIGPROF    |29|Завершение                |Истечение таймера профилирования |
|SIGXCPU    |30|Завершение с дампом памяти|Процесс превысил лимит процессорного времени |
|SIGXFSZ    |31|Завершение с дампом памяти|Процесс превысил допустимый размер файла |

Как Вы моги заметить, существует огромное множество сигналов, используемых для обработки самых разнообразных событий.
Давайте создадим приложение, позволяющее попробовать управление процессами при помощи сигналов.

## Обработчик сигналов
1. Для начала создайте любым удобным для Вас способом файл `signals.c`
2. После этого вставьте в него следующий код (особенности его работы Вы разберете на дисциплине "Системное программирование в ОС Linux" в первом семестре третьего курса.
```
    #include <signal.h>
    #include <stdio.h>
    #include <unistd.h>
    #include <errno.h>
    #include <stdlib.h>
    #include <string.h>
    
    volatile sig_atomic_t signal_number, counter = 3;
    void handler(int signo) {
        signal_number = signo;
    }
    int main(int argc, char **argv) {
        ssize_t length = 128;
        const char* path = "/home/user/file.txt";
        FILE *file;
        char *buffer;
        if((file = fopen(path, "r")) == NULL){
            perror("can't open file\n");
            exit(1);
        }
        fgets(buffer, length, file);
        printf("\n%s", buffer); 
        if((fclose(file)) != 0){
            perror("error on closing file");
            exit(1);
        }
        sigset_t set;
        struct sigaction act;
        sigemptyset(&set);
        sigaddset(&set, SIGINT);
        sigprocmask(SIG_BLOCK, &set, NULL);
        act.sa_mask = set;
        act.sa_handler = handler;
        act.sa_flags = 0;
        sigaction(SIGINT, &act, NULL);
        sigemptyset(&set);
        printf("my pid %d\n", getpid());
        while(counter--){
            sigsuspend(&set);
            if (errno != EINTR) {
                perror("error on sigsuspend");
                exit(EXIT_FAILURE);
            }
            if((file = fopen(path, "r")) == NULL){
            perror("can't open file\n");
            exit(1);
            }
            fgets(buffer, length, file);
            printf("\n%s", buffer); 
            if((fclose(file)) != 0) {
                perror("error on closing file");
                exit(1);
            }
        }
        exit(EXIT_SUCCESS);
    }
 ```

Пока что достаточно лишь знать, что данный код включает в себя обработчик пришедших сигналов. 

3. Создайте в /home/user файл `file.txt` и напишите в него какое-нибудь слово. Сохраните файл.
4. Перейдите в директорию, в которой Вы создавали файл `signals.c`, после чего выполните:
 ``` gcc signals.c -o signals.out```
 Эта команда скомпилирует исходный код из файла `signals.c` в исполняемый файл `signals.out`
С особенностями компилятора **gcc** Вы ознакомитесь позднее.
5. После того, как в директории появился файл `signals.out`, давайте его запустим
```./singnals.out```
После запуска программа напишет в чат свой **pid**, а также слово, прочитанное из Вашего файла. 
6. Измените содержимое файла, написав в него новое слово. 
7. Откройте новое окно терминала и напишите в нём 
```kill -2 pid ```, где _pid_ - то значение, которое Вам вернула программа. 

После выполнения этой команды процессу будет послан сигнал под номером 2 из таблицы. Программа написана таким образом, что при получении этого сигнала сработает соответствующий обработчик, который заново прочитает слово из файла и выведет его в консоль. 
Попробуйте проделать это еще раз.
После третьего выполнения команды `kill` основная команда завершится.

_Кстати_, в соответствии с таблицей команду `kill -2 pid` можно заменить на сочетание клавиш `Ctrl+C` в окне с запущенной программой. Попробуйте самостоятельно.
